#!/usr/bin/python

from __future__ import annotations

# Standard Library
import argparse
import sys
from pathlib import Path
from typing import List
from importlib import import_module
from os.path import basename, dirname
from typing import Tuple, Callable, Any

# Custom Library
from lark import Lark, Transformer, v_args
from lark.lexer import Token
from lark.tree import Tree
from typeguard import typechecked as strict

# Personal Library

arg_parser = argparse.ArgumentParser(
        prog="simpl",
        description="Compiler for SiMPL",
        epilog="by sizzleru"
)

arg_parser.add_argument("-f", "--file")
#parser.add_argument("-v", "--verbose")

def load_module(module_path: Path) -> None:
    if not module_path.is_file():
        raise FileNotFoundError

    module_name = (dirname(module_path) + '/' + module_path.stem).replace("/",".")
    return (import_module(module_name).Module)()


@v_args(inline=True)
@strict
class SiMPLTransformer(Transformer):
    def load(self: Transformer, token: Token):
        modules.append(load_module(Path(token)))
        return None

    def printable(self: Transformer, token: Token):
        print(str(token))
        #return int(token)

    #def command(self, tree: Any):
    #    return None

    #def line(self, tree: Any):
    #    return None

def generate_parser(modules):
    final_grammar = "line:command\"\\n\"line?\n"

    modules.sort(key=lambda module: module.token_from())
    seen_modules = set(['line'])

    for module in modules:
        if not module.token_from() in seen_modules:
            final_grammar += module.token_from() + ":" + module.token() + "\n"
            seen_modules.add(module.token_from())
        else:
            final_grammar += "|" + module.token() + "\n"

    return Lark(final_grammar, start="line")


if __name__ == "__main__":

    # Allow module imports
    initial_modules = [
            'module/default/system/module/base/v0_0_1.py',
            'module/default/system/load/base/v0_0_1.py',
    ]

    modules = []
    for initial_module in map(Path, initial_modules):
        modules.append(load_module(initial_module))
    parser = generate_parser(modules)

    if (input_file := arg_parser.parse_args().file) != "":
        file_contents = []
        file_segment = ""
        chain_load = False

        file = open(input_file, "r")
        for line in file:
            if line.split(' ')[0] == 'load':
                if chain_load:
                    file_segment += line
                else:
                    if file_segment != "":
                        file_contents.append(file_segment)
                    chain_load = True
                    file_segment = line
            else:
                if chain_load:
                    chain_load = False
                    if file_segment != "":
                        file_contents.append(file_segment)
                    file_segment = line
                else:
                    file_segment += line
        if file_segment != "":
            file_contents.append(file_segment)

        for file_segment in file_contents:
            tree = parser.parse(file_segment)
            #print(tree.pretty())
            leftover = SiMPLTransformer().transform(tree)
            parser = generate_parser(modules)

        #print(leftover)
    else:
        raise NotImplementedError

